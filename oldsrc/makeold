export CC = gcc
export CFLAGS = -ansi -Wall -pedantic -O

export LD = gcc
export LDFLAGS = -O
export NVLDFLAGS = -L$(CUDA_HOME)/lib64 -lcudart -lstdc++

export NVCC = nvcc
export NVCFLAGS = -c -O

export BUILD = build

# Builds things such as rsv0/librsv0 using
# the makefile found in that subdir.
%/lib%.a:
	$(MAKE) -C $(@D) $(@F)

%.o: %.c
	$(CC) -c $(CFLAGS) $^

$(BUILD)/%: main.o %/lib%.a
	$(LD) $< -I. -L$(@F) -l$(@F) -o $@ $(LDFLAGS)

%.o: %.cu
	$(NVCC) $(NVCFLAGS) -o $@ $^

# serial implementation using CPU only of randsum
$(BUILD)/r.s0: main.o serial/exp.o serial/r.o
	$(LD) $^ -o $@ $(LDFLAGS)

# handles randsum in a kernel
$(BUILD)/r.p0: cuda/r0.o serial/exp.o main.o
	$(CC) $^ -o $@ $(LDFLAGS) $(NVLDFLAGS)

# uses mapped memory
$(BUILD)/r.p1: cuda/r1.o serial/exp.o main.o
	$(CC) $^ -o $@ $(LDFLAGS) $(NVLDFLAGS)

# avoid unregistering paged memory
$(BUILD)/r.p4: cuda/r4.o serial/exp.o main.o
	$(CC) $^ -o $@ $(LDFLAGS) $(NVLDFLAGS)

# uses cudaHostAlloc and the cuda version of exp.cu
$(BUILD)/r.p5: cuda/r5.o cuda/exp.o main.o
	$(CC) $^ -o $@ $(LDFLAGS) $(NVLDFLAGS)
clean:
	rm -f *.o *.gch build/*
	$(MAKE) -C rsv0 clean

